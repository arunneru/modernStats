---
title: "chapter-clustering-validation"
author: "Ar"
date: '2022-07-19'
output: pdf_document
---

# Need for validation of clusters 
Clustering algorithms are designed such that they come out with a given number of clusters even if the underlying data is devoid of any such clusters.
We will see a criterion to assess the credibility of the clusters produced by any clustering algorithm.

## Within-groups sum of squared distances (WSS): 

$$
WSS_k =  \sum_{l=1}^k{\sum_{x_i \in {C_l}}{d^2(x_i, \overline{x_l})}}
$$

where, $k$ is the number of clusters and within the l-th cluster $C_l$, $x_l$ is the centre of mass.
We are interested in finding the *elbow* where there is a sudden drop in WSS_k as k is increased. 

```{r}
library("tidyverse")
library("dplyr")
simdat <- lapply(c(0, 5, 10), function(mx) {
    lapply(c(0, 5, 10), function(my) {
        tibble(
            x = rnorm(100, mean = mx, sd = 1),
            y = rnorm(100, mean = my, sd = 1),
            class = paste(mx, my, sep = ":")
        )
    }) %>% bind_rows()
}) %>% bind_rows()

simdatxy <- simdat[, c("x", "y")]
ggplot(simdat, aes(x = x, y = y, col = class)) +
    geom_point() +
    coord_fixed()

wss <- tibble(k = 1:12, value = NA_real_)
wss$value[1] <- sum(scale(simdatxy, scale = FALSE)^2)
for (i in 2:nrow(wss)) {
    km <- kmeans(simdatxy, centers = wss$k[i])
    wss$value[i] <- sum(km$withinss)
}

ggplot(wss, aes(x = k, y = value)) +
    geom_col()
```

## Calinski-Harabasz index

There was an issue with using just the WSS_k. Sometimes, there are more than one sudden drops (Try running the example with datasets that vary in the spread from the center of the chosen cluster). For some cases, there might be more than one drop. 


$$
CH(k) =  {BSS_k \over WSS_k} \times { N-k \over N-1} \ \  where \ \ BSS_k = \sum_{l=1}^k{n_l(\bar{x_l}-\bar{x})^2}
$$




```{r}
library("fpc")
library("cluster")
CH = tibble(
  k = 2:12,
  value = sapply(k, function(i) {
    p = pam(simdatxy, i)
    calinhara(simdatxy, p$cluster)
  })
)
ggplot(CH, aes(x = k, y = value)) + geom_line() + geom_point() +
  ylab("CH index")
```

```{r}
simdat
```



```{r}
reference.source <-  lapply(1:20, function(i){tibble(
            x = runif(900, min = min(simdat$x), max = max(simdat$x)),
            y = runif(900, min = min(simdat$y), max = max(simdat$y)),
            class = "unif"
        )} )

```

```{r}
ggplot(reference.source[[8]], aes(x=x, y=y))+geom_point()
```
```{r}
library("cluster")
```


```{r}
pamfun = function(x, k)
  list(cluster=pam(x,k,cluster.only = TRUE))

gss=clusGap(simdatxy, FUN=pamfun, K.max=12, B=50, verbose=FALSE)

gss

```
```{r}
plot_gap = function(x){
  
  gstab = data.frame(x$Tab, k=seq_len(nrow(x$Tab)))
  ggplot(gstab, aes(k, gap))+geom_line()+
    geom_errorbar(aes(ymax=gap+SE.sim,
                      ymin=gap-SE.sim), width=0.1)+
    geom_point(size=3, col="red")
}
```


```{r}
plot_gap(gss)
```





```{r}
simdat.unif <- lapply(c(0, 8), function(mx) {
    lapply(c(0, 8), function(my) {
        tibble(
            x = runif(100, min = min(simdat$x), max = max(simdat$x)),
            y = runif(100, min = min(simdat$y), max = max(simdat$y)),
            class = "unif"
        )
    }) %>% bind_rows()
}) %>% bind_rows()

```


```{r}
simdatxy.unif <- simdat.unif[, c("x", "y")]
ggplot(simdat.unif, aes(x = x, y = y, col = class)) +
    geom_point() +
    coord_fixed()
```

```{r}
wss.unif <- tibble(k = 1:8, value = NA_real_)
wss.unif$value[1] <- sum(scale(simdatxy.unif, scale = FALSE)^2)
for (i in 2:nrow(wss.unif)) {
    km <- kmeans(simdatxy.unif, centers = wss.unif$k[i])
    wss.unif$value[i] <- sum(km$withinss)
}

ggplot(wss.unif, aes(x = k, y = value)) +
    geom_col()
```




